<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1" />
  <title>Mytier Meteor-10</title>
  <style>
    :root { color-scheme: dark; }
    html,body{margin:0;height:100%;background:#070a12;font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial;}
    #wrap{height:100%;display:flex;align-items:center;justify-content:center;padding:10px;box-sizing:border-box;}
    #game{
      width:min(1100px,100vw);
      height:min(720px,100vh);
      position:relative;
      border-radius:18px;
      border:1px solid rgba(255,255,255,.14);
      overflow:hidden;
      box-shadow:0 18px 60px rgba(0,0,0,.55);
      background:#0b0f1a;
      touch-action:none;
      user-select:none;
    }
    canvas{position:absolute;inset:0;width:100%;height:100%;display:block;z-index:2;}
    .topbar{
      position:absolute; left:14px; right:14px; top:12px;
      display:flex; justify-content:space-between; align-items:center; gap:10px;
      z-index:5; pointer-events:auto;
    }
    .pill{
      display:flex; align-items:center; gap:10px; flex-wrap:wrap;
      padding:10px 12px;
      border-radius:14px;
      background:rgba(0,0,0,.35);
      border:1px solid rgba(255,255,255,.14);
      backdrop-filter: blur(6px);
      font-size:13px;
      color:#eaf0ff;
    }
    .pill b{font-weight:900;}
    button{
      border-radius:12px; border:1px solid rgba(255,255,255,.18);
      background:rgba(255,255,255,.10); color:#eaf0ff;
      padding:10px 12px; font-weight:800; cursor:pointer;
    }
    button:hover{background:rgba(255,255,255,.14);}
    button:active{transform:translateY(1px);}

    .hint{
      position:absolute; left:14px; right:14px; bottom:12px;
      z-index:5; display:flex; justify-content:space-between; gap:10px; flex-wrap:wrap;
      pointer-events:none;
    }
    .hint .box{
      padding:10px 12px; border-radius:14px;
      background:rgba(0,0,0,.35);
      border:1px solid rgba(255,255,255,.14);
      backdrop-filter: blur(6px);
      color:#eaf0ff; font-size:12px; opacity:.9; line-height:1.35;
      max-width:72%;
    }

    .overlay{
      position:absolute; inset:0; z-index:30;
      display:none; align-items:center; justify-content:center;
      background:rgba(0,0,0,.55);
      backdrop-filter: blur(6px);
      color:#fff;
    }
    .card{
      width:min(520px,92vw);
      border-radius:18px;
      border:1px solid rgba(255,255,255,.18);
      background:rgba(10,12,20,.75);
      padding:18px;
      text-align:center;
      box-shadow:0 18px 60px rgba(0,0,0,.55);
    }
    .card h2{margin:0 0 8px;font-size:22px;}
    .card p{margin:0 0 14px;opacity:.9;}
    .row{display:flex; gap:10px; justify-content:center; flex-wrap:wrap;}
  </style>
</head>
<body>
<div id="wrap">
  <div id="game">
    <canvas id="c"></canvas>

    <div class="topbar">
      <div class="pill">
        ü™ê <span>Score</span> <b id="score">0</b>
        <span style="opacity:.6">|</span>
        üéØ <span>Target</span> <b>10</b>
        <span style="opacity:.6">|</span>
        üîó <span>Chain</span> <b id="chainsum">0</b>
        <span style="opacity:.6">|</span>
        ‚è≥ <span>Time</span> <b id="time">02:00</b>
      </div>
      <div style="display:flex; gap:10px;">
        <button id="resetBtn">Reset</button>
        <button id="shuffleBtn">Shuffle</button>
      </div>
    </div>

    <div class="hint">
      <div class="box">
        Drag meteors (4-direction). Sum = <b>10</b> ‚Üí break + score. Empty cells stay empty (no refill).
      </div>
      <div class="box" style="max-width:260px;text-align:right;">
        Rule: up/down/left/right only
      </div>
    </div>

    <div class="overlay" id="overlay">
      <div class="card">
        <h2>Time Over</h2>
        <p>Final Score: <b id="finalScore">0</b></p>
        <div class="row">
          <button id="playAgain">Play Again</button>
        </div>
      </div>
    </div>

  </div>
</div>

<script>
(() => {
  const canvas = document.getElementById('c');
  const ctx = canvas.getContext('2d', { alpha:true });
  const gameEl = document.getElementById('game');

  const $score = document.getElementById('score');
  const $chainsum = document.getElementById('chainsum');
  const $time = document.getElementById('time');
  const resetBtn = document.getElementById('resetBtn');
  const shuffleBtn = document.getElementById('shuffleBtn');

  const overlay = document.getElementById('overlay');
  const finalScore = document.getElementById('finalScore');
  const playAgain = document.getElementById('playAgain');

  // IMPORTANT: paths assume index.html is at repo ROOT
  const raw = {
    bg: new Image(),
    meteor: new Image(),
    meteorBreak: new Image(),
  };
  raw.bg.src = "assets/bg.png";
  raw.meteor.src = "assets/meteor.png";
  raw.meteorBreak.src = "assets/meteor_break.png";

  // processed images (white removed)
  const img = { bg: raw.bg, meteor: null, meteorBreak: null };

  // Board settings
  const GRID_COLS = 10, GRID_ROWS = 10;
  let grid = [];
  let score = 0;

  // timer (2 minutes)
  const TOTAL_TIME = 120; // seconds
  let timeLeft = TOTAL_TIME;
  let gameOver = false;

  // interaction
  let dragging = false;
  let chain = [];
  let chainSum = 0;
  let pointerId = null;

  function randN(){ return 1 + Math.floor(Math.random()*9); } // 1..9

  function initGrid(){
    grid = [];
    for (let r=0;r<GRID_ROWS;r++){
      const row = [];
      for (let c=0;c<GRID_COLS;c++){
        row.push({ n: randN(), alive:true, breakT:0 });
      }
      grid.push(row);
    }
    score = 0;
    chain = [];
    chainSum = 0;
    timeLeft = TOTAL_TIME;
    gameOver = false;
    overlay.style.display = "none";
    updateHud();
  }

  function shuffleAliveNumbers(){
    const nums = [];
    for (let r=0;r<GRID_ROWS;r++){
      for (let c=0;c<GRID_COLS;c++){
        const cell = grid[r][c];
        if (cell.alive) nums.push(cell.n);
      }
    }
    for (let i=nums.length-1;i>0;i--){
      const j = Math.floor(Math.random()*(i+1));
      [nums[i], nums[j]] = [nums[j], nums[i]];
    }
    let k=0;
    for (let r=0;r<GRID_ROWS;r++){
      for (let c=0;c<GRID_COLS;c++){
        const cell = grid[r][c];
        if (cell.alive) cell.n = nums[k++];
      }
    }
  }

  function fmtTime(s){
    s = Math.max(0, Math.floor(s));
    const m = String(Math.floor(s/60)).padStart(2,'0');
    const ss = String(s%60).padStart(2,'0');
    return `${m}:${ss}`;
  }

  function updateHud(){
    $score.textContent = String(score);
    $chainsum.textContent = String(chainSum);
    $time.textContent = fmtTime(timeLeft);
  }

  function endGame(){
    gameOver = true;
    dragging = false;
    chain = [];
    chainSum = 0;
    updateHud();
    finalScore.textContent = String(score);
    overlay.style.display = "flex";
  }

  // Layout: draw bg.png frame, then inner grid.
  function getRects(){
    const w = gameEl.clientWidth;
    const h = gameEl.clientHeight;

    const marginTop = 70;
    const marginBottom = 70;
    const boardW = Math.min(w - 40, 980);
    const boardH = Math.min(h - (marginTop+marginBottom), 520);

    const boardX = (w - boardW)/2;
    const boardY = (h - boardH)/2 + 10;

    // tuned padding for your frame image
    const padL = boardW * 0.105;
    const padR = boardW * 0.065;
    const padT = boardH * 0.235;
    const padB = boardH * 0.135;

    const innerX = boardX + padL;
    const innerY = boardY + padT;
    const innerW = boardW - padL - padR;
    const innerH = boardH - padT - padB;

    const cellW = innerW / GRID_COLS;
    const cellH = innerH / GRID_ROWS;

    return { w,h, boardX,boardY,boardW,boardH, innerX,innerY,innerW,innerH, cellW,cellH };
  }

  function resize(){
    const rect = gameEl.getBoundingClientRect();
    const dpr = devicePixelRatio || 1;
    canvas.width = Math.floor(rect.width * dpr);
    canvas.height = Math.floor(rect.height * dpr);
    ctx.setTransform(dpr,0,0,dpr,0,0);
  }
  window.addEventListener('resize', resize);

  function inBounds(r,c){ return r>=0 && r<GRID_ROWS && c>=0 && c<GRID_COLS; }
  function isSame(a,b){ return a.r===b.r && a.c===b.c; }
  function isAdj(a,b){
    const dr = Math.abs(a.r-b.r), dc = Math.abs(a.c-b.c);
    return (dr+dc)===1;
  }
  function cellAtPoint(x,y){
    const R = getRects();
    if (x < R.innerX || x > R.innerX + R.innerW || y < R.innerY || y > R.innerY + R.innerH) return null;
    const c = Math.floor((x - R.innerX) / R.cellW);
    const r = Math.floor((y - R.innerY) / R.cellH);
    if (!inBounds(r,c)) return null;
    return {r,c};
  }

  function recalcChainSum(){
    chainSum = 0;
    for (const p of chain){
      const cell = grid[p.r][p.c];
      if (cell && cell.alive) chainSum += cell.n;
    }
    updateHud();
  }

  function tryAddToChain(pos){
    const cell = grid[pos.r][pos.c];
    if (!cell.alive) return;

    if (chain.length === 0){
      chain.push(pos);
      recalcChainSum();
      return;
    }

    const last = chain[chain.length-1];

    // back one step
    if (chain.length >= 2){
      const prev = chain[chain.length-2];
      if (isSame(pos, prev)){
        chain.pop();
        recalcChainSum();
        return;
      }
    }

    // no reuse
    for (const p of chain){
      if (isSame(p,pos)) return;
    }

    if (!isAdj(last,pos)) return;

    chain.push(pos);
    recalcChainSum();
  }

  function commitChainIfTen(){
    if (chainSum !== 10 || chain.length === 0) {
      chain = [];
      chainSum = 0;
      updateHud();
      return;
    }

    for (const p of chain){
      const cell = grid[p.r][p.c];
      cell.breakT = 0.35;
      cell.alive = false; // empty after animation window
    }
    score += 10;
    chain = [];
    chainSum = 0;
    updateHud();
  }

  function getLocalXY(e){
    const rect = gameEl.getBoundingClientRect();
    return { x: e.clientX - rect.left, y: e.clientY - rect.top };
  }

  gameEl.addEventListener('pointerdown', (e) => {
    if (e.target.tagName === 'BUTTON') return;
    if (gameOver) return;

    try { gameEl.setPointerCapture(e.pointerId); } catch {}
    pointerId = e.pointerId;
    dragging = true;
    chain = [];
    chainSum = 0;

    const p = getLocalXY(e);
    const pos = cellAtPoint(p.x,p.y);
    if (pos) tryAddToChain(pos);
  });

  gameEl.addEventListener('pointermove', (e) => {
    if (!dragging || e.pointerId !== pointerId) return;
    if (gameOver) return;

    const p = getLocalXY(e);
    const pos = cellAtPoint(p.x,p.y);
    if (pos) tryAddToChain(pos);
  });

  function endDrag(e){
    if (!dragging || e.pointerId !== pointerId) return;
    dragging = false;
    pointerId = null;
    if (!gameOver) commitChainIfTen();
  }
  gameEl.addEventListener('pointerup', endDrag);
  gameEl.addEventListener('pointercancel', endDrag);

  resetBtn.addEventListener('click', () => initGrid());
  shuffleBtn.addEventListener('click', () => { if (!gameOver) shuffleAliveNumbers(); });

  playAgain.addEventListener('click', () => initGrid());

  // --- White background auto-remove (key out near-white pixels) ---
  function removeNearWhiteToTransparent(image, threshold=245){
    const c = document.createElement('canvas');
    c.width = image.naturalWidth;
    c.height = image.naturalHeight;
    const x = c.getContext('2d', { willReadFrequently:true });
    x.drawImage(image, 0, 0);
    const data = x.getImageData(0,0,c.width,c.height);
    const d = data.data;
    for (let i=0;i<d.length;i+=4){
      const r=d[i], g=d[i+1], b=d[i+2], a=d[i+3];
      if (a===0) continue;
      if (r>=threshold && g>=threshold && b>=threshold){
        d[i+3] = 0; // transparent
      }
    }
    x.putImageData(data,0,0);
    const out = new Image();
    out.src = c.toDataURL('image/png');
    return out;
  }

  let last = performance.now();
  function loop(now){
    const dt = Math.min(0.05, (now-last)/1000);
    last = now;

    if (!gameOver){
      timeLeft -= dt;
      if (timeLeft <= 0){
        timeLeft = 0;
        endGame();
      }
    }

    // break animation timers
    for (let r=0;r<GRID_ROWS;r++){
      for (let c=0;c<GRID_COLS;c++){
        const cell = grid[r][c];
        if (cell.breakT > 0) cell.breakT = Math.max(0, cell.breakT - dt);
      }
    }

    draw();
    requestAnimationFrame(loop);
  }

  function draw(){
    const R = getRects();
    ctx.clearRect(0,0,R.w,R.h);

    // subtle space background
    ctx.save();
    ctx.fillStyle = "#050812";
    ctx.fillRect(0,0,R.w,R.h);
    ctx.globalAlpha = 0.12;
    ctx.fillStyle = "#fff";
    for (let i=0;i<55;i++){
      const x = (i*73 % 997) / 997 * R.w;
      const y = (i*151 % 773) / 773 * R.h;
      const s = (i % 3) + 1;
      ctx.globalAlpha = 0.06 + (i%5)*0.02;
      ctx.fillRect(x,y, s, s);
    }
    ctx.restore();

    // board frame bg image
    if (img.bg.complete && img.bg.naturalWidth){
      ctx.drawImage(img.bg, R.boardX, R.boardY, R.boardW, R.boardH);
    } else {
      ctx.save();
      ctx.fillStyle = "rgba(15,20,40,.9)";
      ctx.strokeStyle = "rgba(255,255,255,.15)";
      ctx.lineWidth = 2;
      roundRect(R.boardX,R.boardY,R.boardW,R.boardH,18,true,true);
      ctx.restore();
    }

    // cells
    for (let r=0;r<GRID_ROWS;r++){
      for (let c=0;c<GRID_COLS;c++){
        const cell = grid[r][c];
        const x = R.innerX + c*R.cellW;
        const y = R.innerY + r*R.cellH;

        if (!cell.alive && cell.breakT <= 0) continue;

        const iconImg = (cell.breakT > 0) ? img.meteorBreak : img.meteor;
        const pad = Math.min(R.cellW,R.cellH) * 0.10;
        const iw = R.cellW - pad*2;
        const ih = R.cellH - pad*2;

        if (iconImg && iconImg.complete && iconImg.naturalWidth){
          ctx.save();
          ctx.globalAlpha = 0.95;
          ctx.drawImage(iconImg, x+pad, y+pad, iw, ih);
          ctx.restore();
        }

        drawNumber(cell.n, x+R.cellW/2, y+R.cellH/2, Math.min(R.cellW,R.cellH));
      }
    }

    // chain path
    if (chain.length > 0){
      ctx.save();
      ctx.lineWidth = 8;
      ctx.lineJoin = "round";
      ctx.lineCap = "round";
      ctx.strokeStyle = "rgba(110,220,255,.55)";
      ctx.beginPath();
      for (let i=0;i<chain.length;i++){
        const p = chain[i];
        const x = R.innerX + p.c*R.cellW + R.cellW/2;
        const y = R.innerY + p.r*R.cellH + R.cellH/2;
        if (i===0) ctx.moveTo(x,y); else ctx.lineTo(x,y);
      }
      ctx.stroke();
      ctx.restore();
    }
  }

  function drawNumber(n, cx, cy, cellSize){
    const fs = Math.max(14, cellSize * 0.30);
    ctx.save();
    ctx.font = `900 ${fs}px system-ui, -apple-system, Segoe UI, Roboto, Arial`;
    ctx.textAlign = "center";
    ctx.textBaseline = "middle";
    ctx.lineWidth = Math.max(3, fs*0.14);
    ctx.strokeStyle = "rgba(0,0,0,.70)";
    ctx.strokeText(String(n), cx, cy);
    ctx.fillStyle = "rgba(255,235,170,.95)";
    ctx.fillText(String(n), cx, cy);
    ctx.restore();
  }

  function roundRect(x,y,w,h,r,fill,stroke){
    const rr = Math.min(r, w/2, h/2);
    ctx.beginPath();
    ctx.moveTo(x+rr,y);
    ctx.arcTo(x+w,y,x+w,y+h,rr);
    ctx.arcTo(x+w,y+h,x,y+h,rr);
    ctx.arcTo(x,y+h,x,y,rr);
    ctx.arcTo(x,y,x+w,y,rr);
    ctx.closePath();
    if (fill) ctx.fill();
    if (stroke) ctx.stroke();
  }

  function waitImages(){
    return new Promise((resolve) => {
      const imgs = [raw.bg, raw.meteor, raw.meteorBreak];
      let left = imgs.length;
      const done = () => { left--; if (left<=0) resolve(); };
      imgs.forEach(im => {
        if (im.complete) done();
        else { im.onload = done; im.onerror = done; }
      });
    });
  }

  resize();
  initGrid();

  waitImages().then(() => {
    // auto-remove near-white background from meteor icons
    // threshold can be tuned: 235~250
    img.meteor = removeNearWhiteToTransparent(raw.meteor, 245);
    img.meteorBreak = removeNearWhiteToTransparent(raw.meteorBreak, 245);
    requestAnimationFrame(loop);
  });

})();
</script>
</body>
</html>
