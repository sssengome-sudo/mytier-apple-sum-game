<!doctype html>
<html lang="ko">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1" />
  <title>Mytier Meteor-10</title>
  <style>
    :root { color-scheme: dark; }
    html,body{margin:0;height:100%;background:#070a12;font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial;}
    #wrap{height:100%;display:flex;align-items:center;justify-content:center;padding:10px;box-sizing:border-box;}
    #game{
      width:min(1100px,100vw);
      height:min(720px,100vh);
      position:relative;
      border-radius:18px;
      border:1px solid rgba(255,255,255,.14);
      overflow:hidden;
      box-shadow:0 18px 60px rgba(0,0,0,.55);
      background:#0b0f1a;
      touch-action:none;
      user-select:none;
    }

    /* optional banner (if you upload assets/banner.jpg) */
    #banner{
      position:absolute; inset:0;
      background:
        radial-gradient(900px 600px at 50% 25%, rgba(35,50,95,.85) 0%, rgba(10,12,20,.95) 70%),
        url("assets/banner.jpg");
      background-size:cover;
      background-position:center;
      filter:saturate(1.05) contrast(1.05);
      opacity:.28;
      z-index:0;
    }

    canvas{position:absolute;inset:0;width:100%;height:100%;display:block;z-index:2;}

    .topbar{
      position:absolute; left:14px; right:14px; top:12px;
      display:flex; justify-content:space-between; align-items:center; gap:10px;
      z-index:5;
      pointer-events:auto;
    }
    .pill{
      display:flex; align-items:center; gap:10px; flex-wrap:wrap;
      padding:10px 12px;
      border-radius:14px;
      background:rgba(0,0,0,.35);
      border:1px solid rgba(255,255,255,.14);
      backdrop-filter: blur(6px);
      font-size:13px;
      color:#eaf0ff;
    }
    .pill b{font-weight:800;}
    button{
      border-radius:12px;
      border:1px solid rgba(255,255,255,.18);
      background:rgba(255,255,255,.10);
      color:#eaf0ff;
      padding:10px 12px;
      font-weight:750;
      cursor:pointer;
    }
    button:hover{background:rgba(255,255,255,.14);}
    button:active{transform:translateY(1px);}

    .hint{
      position:absolute; left:14px; right:14px; bottom:12px;
      z-index:5;
      display:flex; justify-content:space-between; gap:10px; flex-wrap:wrap;
      pointer-events:none;
    }
    .hint .box{
      pointer-events:none;
      max-width: 72%;
      padding:10px 12px;
      border-radius:14px;
      background:rgba(0,0,0,.35);
      border:1px solid rgba(255,255,255,.14);
      backdrop-filter: blur(6px);
      color:#eaf0ff;
      font-size:12px;
      opacity:.9;
      line-height:1.35;
    }

    .error{
      position:absolute; left:14px; right:14px; top:70px;
      z-index:20;
      background:rgba(255,80,80,.10);
      border:1px solid rgba(255,120,120,.35);
      border-radius:12px;
      padding:10px 12px;
      font-size:12px;
      display:none;
      white-space:pre-wrap;
    }
  </style>
</head>
<body>
<div id="wrap">
  <div id="game">
    <div id="banner"></div>
    <canvas id="c"></canvas>

    <div class="topbar">
      <div class="pill">
        ğŸª <span>Score</span> <b id="score">0</b>
        <span style="opacity:.65">|</span>
        ğŸ¯ <span>Target</span> <b>10</b>
        <span style="opacity:.65">|</span>
        ğŸ”— <span>Chain Sum</span> <b id="chainsum">0</b>
      </div>
      <div style="display:flex; gap:10px;">
        <button id="resetBtn">Reset</button>
        <button id="shuffleBtn">Shuffle</button>
      </div>
    </div>

    <div class="hint">
      <div class="box">
        ë“œë˜ê·¸ë¡œ ë©”í…Œì˜¤ë¥¼ ì—°ê²°í•´ì„œ í•©ì´ <b>10</b>ì´ ë˜ë©´ í•´ë‹¹ ë©”í…Œì˜¤ê°€ <b>ê¹¨ì§€ê³ (ì‚­ì œ)</b> ì ìˆ˜ ìƒìŠ¹.<br/>
        <b>ë¹ˆì¹¸ì€ ê·¸ëŒ€ë¡œ ìœ ì§€</b>(ë¦¬í•„ ì—†ìŒ). ëª¨ë°”ì¼ë„ ë“œë˜ê·¸ ê°€ëŠ¥.
      </div>
      <div class="box" style="max-width:260px;text-align:right;">
        ê·œì¹™: ìƒí•˜ì¢Œìš° ì¸ì ‘ë§Œ ì—°ê²°
      </div>
    </div>

    <div class="error" id="errorBox"></div>
  </div>
</div>

<script>
(() => {
  const canvas = document.getElementById('c');
  const ctx = canvas.getContext('2d', { alpha:true });
  const gameEl = document.getElementById('game');
  const errorBox = document.getElementById('errorBox');

  const $score = document.getElementById('score');
  const $chainsum = document.getElementById('chainsum');
  const resetBtn = document.getElementById('resetBtn');
  const shuffleBtn = document.getElementById('shuffleBtn');

  function showError(msg){
    errorBox.style.display = 'block';
    errorBox.textContent = msg;
  }

  // Assets (YOU must upload these into repo)
  const assets = {
    bg: new Image(),
    meteor: new Image(),
    meteorBreak: new Image(),
    banner: null
  };
  assets.bg.src = "assets/bg.png";
  assets.meteor.src = "assets/meteor.png";
  assets.meteorBreak.src = "assets/meteor_break.png";

  // if banner.jpg not exist, ignore
  // (CSS uses it; missing file just results in no image, that's fine)

  // Board settings (tune here)
  const GRID_COLS = 10;
  const GRID_ROWS = 10;

  // cell data: {n:number, alive:boolean, breakT:number}
  let grid = [];
  let score = 0;

  // interaction
  let dragging = false;
  let chain = []; // list of {r,c}
  let chainSum = 0;
  let pointerId = null;

  function randN(){ return 1 + Math.floor(Math.random()*9); } // 1..9

  function initGrid(){
    grid = [];
    for (let r=0;r<GRID_ROWS;r++){
      const row = [];
      for (let c=0;c<GRID_COLS;c++){
        row.push({ n: randN(), alive:true, breakT:0 });
      }
      grid.push(row);
    }
    score = 0;
    chain = [];
    chainSum = 0;
    updateHud();
  }

  function shuffleAliveNumbers(){
    const nums = [];
    for (let r=0;r<GRID_ROWS;r++){
      for (let c=0;c<GRID_COLS;c++){
        const cell = grid[r][c];
        if (cell.alive) nums.push(cell.n);
      }
    }
    // Fisher-Yates
    for (let i=nums.length-1;i>0;i--){
      const j = Math.floor(Math.random()*(i+1));
      [nums[i], nums[j]] = [nums[j], nums[i]];
    }
    let k=0;
    for (let r=0;r<GRID_ROWS;r++){
      for (let c=0;c<GRID_COLS;c++){
        const cell = grid[r][c];
        if (cell.alive) cell.n = nums[k++];
      }
    }
  }

  function updateHud(){
    $score.textContent = String(score);
    $chainsum.textContent = String(chainSum);
  }

  // Layout: we draw your bg.png as the board frame, then place cells inside an inner rect.
  // We infer inner rect by padding ratio (tuned for your provided frame).
  function getRects(){
    const w = gameEl.clientWidth;
    const h = gameEl.clientHeight;

    // board area within overall canvas
    const marginTop = 70;
    const marginBottom = 70;
    const boardW = Math.min(w - 40, 980);
    const boardH = Math.min(h - (marginTop+marginBottom), 520);

    const boardX = (w - boardW)/2;
    const boardY = (h - boardH)/2 + 10;

    // inner grid area inside bg frame (tune if needed)
    // these ratios assume your bg.png has thick border/frame.
    const padL = boardW * 0.10;
    const padR = boardW * 0.06;
    const padT = boardH * 0.22;
    const padB = boardH * 0.12;

    const innerX = boardX + padL;
    const innerY = boardY + padT;
    const innerW = boardW - padL - padR;
    const innerH = boardH - padT - padB;

    const cellW = innerW / GRID_COLS;
    const cellH = innerH / GRID_ROWS;

    return { w,h, boardX,boardY,boardW,boardH, innerX,innerY,innerW,innerH, cellW,cellH };
  }

  function resize(){
    const rect = gameEl.getBoundingClientRect();
    const dpr = devicePixelRatio || 1;
    canvas.width = Math.floor(rect.width * dpr);
    canvas.height = Math.floor(rect.height * dpr);
    ctx.setTransform(dpr,0,0,dpr,0,0);
  }
  window.addEventListener('resize', resize);

  // Helpers
  function inBounds(r,c){ return r>=0 && r<GRID_ROWS && c>=0 && c<GRID_COLS; }
  function isSame(a,b){ return a.r===b.r && a.c===b.c; }
  function isAdj(a,b){
    const dr = Math.abs(a.r-b.r), dc = Math.abs(a.c-b.c);
    return (dr+dc)===1;
  }
  function cellAtPoint(x,y){
    const R = getRects();
    if (x < R.innerX || x > R.innerX + R.innerW || y < R.innerY || y > R.innerY + R.innerH) return null;
    const c = Math.floor((x - R.innerX) / R.cellW);
    const r = Math.floor((y - R.innerY) / R.cellH);
    if (!inBounds(r,c)) return null;
    return {r,c};
  }

  function recalcChainSum(){
    chainSum = 0;
    for (const p of chain){
      const cell = grid[p.r][p.c];
      if (cell && cell.alive) chainSum += cell.n;
    }
    updateHud();
  }

  function tryAddToChain(pos){
    const cell = grid[pos.r][pos.c];
    if (!cell.alive) return;

    if (chain.length === 0){
      chain.push(pos);
      recalcChainSum();
      return;
    }

    const last = chain[chain.length-1];

    // if user goes back one step
    if (chain.length >= 2){
      const prev = chain[chain.length-2];
      if (isSame(pos, prev)){
        chain.pop();
        recalcChainSum();
        return;
      }
    }

    // no reusing
    for (const p of chain){
      if (isSame(p,pos)) return;
    }

    // must be adjacent
    if (!isAdj(last,pos)) return;

    chain.push(pos);
    recalcChainSum();
  }

  function commitChainIfTen(){
    if (chainSum !== 10 || chain.length === 0) {
      chain = [];
      chainSum = 0;
      updateHud();
      return;
    }

    // break those cells (no refill)
    for (const p of chain){
      const cell = grid[p.r][p.c];
      cell.breakT = 0.35;   // show break icon briefly
      cell.alive = false;   // becomes empty after animation
    }
    score += 10; // scoring rule (tune if needed)
    chain = [];
    chainSum = 0;
    updateHud();
  }

  // Input
  function getLocalXY(e){
    const rect = gameEl.getBoundingClientRect();
    return { x: e.clientX - rect.left, y: e.clientY - rect.top };
  }

  gameEl.addEventListener('pointerdown', (e) => {
    // ignore clicks on buttons
    if (e.target.tagName === 'BUTTON') return;

    try { gameEl.setPointerCapture(e.pointerId); } catch {}
    pointerId = e.pointerId;
    dragging = true;
    chain = [];
    chainSum = 0;

    const p = getLocalXY(e);
    const pos = cellAtPoint(p.x,p.y);
    if (pos) tryAddToChain(pos);
  });

  gameEl.addEventListener('pointermove', (e) => {
    if (!dragging || e.pointerId !== pointerId) return;
    const p = getLocalXY(e);
    const pos = cellAtPoint(p.x,p.y);
    if (pos) tryAddToChain(pos);
  });

  function endDrag(e){
    if (!dragging || e.pointerId !== pointerId) return;
    dragging = false;
    pointerId = null;
    commitChainIfTen();
  }
  gameEl.addEventListener('pointerup', endDrag);
  gameEl.addEventListener('pointercancel', endDrag);

  // Buttons
  resetBtn.addEventListener('click', () => initGrid());
  shuffleBtn.addEventListener('click', () => {
    shuffleAliveNumbers();
  });

  // Update loop
  let last = performance.now();
  function loop(now){
    const dt = Math.min(0.033, (now-last)/1000);
    last = now;

    try{
      // tick break animations
      for (let r=0;r<GRID_ROWS;r++){
        for (let c=0;c<GRID_COLS;c++){
          const cell = grid[r][c];
          if (cell.breakT > 0){
            cell.breakT = Math.max(0, cell.breakT - dt);
          }
        }
      }
      draw();
    } catch (err){
      showError("Runtime error:\n" + (err && err.stack ? err.stack : String(err)));
    }

    requestAnimationFrame(loop);
  }

  function draw(){
    const R = getRects();
    ctx.clearRect(0,0,R.w,R.h);

    // background (dark space + subtle stars)
    ctx.save();
    ctx.globalAlpha = 1;
    // mild stars
    ctx.globalAlpha = 0.20;
    ctx.fillStyle = "#ffffff";
    for (let i=0;i<60;i++){
      const x = (i*73 % 997) / 997 * R.w;
      const y = (i*151 % 773) / 773 * R.h;
      const s = (i % 3) + 1;
      ctx.globalAlpha = 0.08 + (i%5)*0.02;
      ctx.fillRect(x,y, s, s);
    }
    ctx.restore();

    // draw board frame background image
    if (assets.bg.complete && assets.bg.naturalWidth){
      ctx.save();
      ctx.globalAlpha = 0.98;
      ctx.drawImage(assets.bg, R.boardX, R.boardY, R.boardW, R.boardH);
      ctx.restore();
    } else {
      // fallback if bg missing
      ctx.save();
      ctx.fillStyle = "rgba(15,20,40,.9)";
      ctx.strokeStyle = "rgba(255,255,255,.15)";
      ctx.lineWidth = 2;
      roundRect(R.boardX,R.boardY,R.boardW,R.boardH,18,true,true);
      ctx.restore();
    }

    // draw cells
    for (let r=0;r<GRID_ROWS;r++){
      for (let c=0;c<GRID_COLS;c++){
        const cell = grid[r][c];
        const x = R.innerX + c*R.cellW;
        const y = R.innerY + r*R.cellH;

        if (!cell.alive && cell.breakT <= 0){
          // empty cell
          continue;
        }

        // icon
        const iconImg = (cell.breakT > 0) ? assets.meteorBreak : assets.meteor;
        if (iconImg.complete && iconImg.naturalWidth){
          const pad = Math.min(R.cellW,R.cellH) * 0.10;
          const iw = R.cellW - pad*2;
          const ih = R.cellH - pad*2;
          ctx.save();
          ctx.globalAlpha = cell.breakT>0 ? 0.95 : 0.92;
          ctx.drawImage(iconImg, x+pad, y+pad, iw, ih);
          ctx.restore();
        } else {
          // fallback circle
          ctx.save();
          ctx.globalAlpha = 0.85;
          ctx.fillStyle = "rgba(120,220,255,.85)";
          ctx.beginPath();
          ctx.arc(x+R.cellW/2, y+R.cellH/2, Math.min(R.cellW,R.cellH)*0.36, 0, Math.PI*2);
          ctx.fill();
          ctx.restore();
        }

        // number on top (only if cell was alive before breaking; keep number visible during breakT)
        const n = cell.n;
        drawNumber(n, x+R.cellW/2, y+R.cellH/2, Math.min(R.cellW,R.cellH));
      }
    }

    // chain highlight path
    if (chain.length > 0){
      ctx.save();
      ctx.lineWidth = 8;
      ctx.lineJoin = "round";
      ctx.lineCap = "round";
      ctx.strokeStyle = "rgba(110,220,255,.55)";
      ctx.beginPath();
      for (let i=0;i<chain.length;i++){
        const p = chain[i];
        const x = R.innerX + p.c*R.cellW + R.cellW/2;
        const y = R.innerY + p.r*R.cellH + R.cellH/2;
        if (i===0) ctx.moveTo(x,y); else ctx.lineTo(x,y);
      }
      ctx.stroke();

      // nodes highlight
      for (const p of chain){
        const x = R.innerX + p.c*R.cellW + R.cellW/2;
        const y = R.innerY + p.r*R.cellH + R.cellH/2;
        ctx.fillStyle = "rgba(255,255,255,.10)";
        ctx.beginPath();
        ctx.arc(x,y, Math.min(R.cellW,R.cellH)*0.40, 0, Math.PI*2);
        ctx.fill();
      }
      ctx.restore();

      // if sum==10 show glow
      if (chainSum === 10){
        ctx.save();
        ctx.globalAlpha = 0.85;
        ctx.fillStyle = "rgba(140,255,210,.16)";
        for (const p of chain){
          const x = R.innerX + p.c*R.cellW;
          const y = R.innerY + p.r*R.cellH;
          roundRect(x+2,y+2,R.cellW-4,R.cellH-4,10,true,false);
        }
        ctx.restore();
      }
    }
  }

  function drawNumber(n, cx, cy, cellSize){
    // Outline + gold fill ëŠë‚Œ
    const fs = Math.max(14, cellSize * 0.30);
    ctx.save();
    ctx.font = `900 ${fs}px system-ui, -apple-system, Segoe UI, Roboto, Arial`;
    ctx.textAlign = "center";
    ctx.textBaseline = "middle";

    ctx.lineWidth = Math.max(3, fs*0.14);
    ctx.strokeStyle = "rgba(0,0,0,.70)";
    ctx.strokeText(String(n), cx, cy);

    // gold-ish
    ctx.fillStyle = "rgba(255,235,170,.95)";
    ctx.fillText(String(n), cx, cy);

    // subtle inner glow
    ctx.shadowColor = "rgba(255,210,120,.55)";
    ctx.shadowBlur = 10;
    ctx.fillStyle = "rgba(255,210,120,.35)";
    ctx.fillText(String(n), cx, cy);

    ctx.restore();
  }

  function roundRect(x,y,w,h,r,fill,stroke){
    const rr = Math.min(r, w/2, h/2);
    ctx.beginPath();
    ctx.moveTo(x+rr,y);
    ctx.arcTo(x+w,y,x+w,y+h,rr);
    ctx.arcTo(x+w,y+h,x,y+h,rr);
    ctx.arcTo(x,y+h,x,y,rr);
    ctx.arcTo(x,y,x+w,y,rr);
    ctx.closePath();
    if (fill) ctx.fill();
    if (stroke) ctx.stroke();
  }

  // boot
  function waitImages(){
    return new Promise((resolve) => {
      const imgs = [assets.bg, assets.meteor, assets.meteorBreak];
      let left = imgs.length;
      const done = () => { left--; if (left<=0) resolve(); };
      imgs.forEach(img => {
        if (img.complete) done();
        else {
          img.onload = done;
          img.onerror = done; // allow running even if one missing
        }
      });
    });
  }

  resize();
  initGrid();
  waitImages().then(() => requestAnimationFrame(loop));
})();
</script>
</body>
</html>
